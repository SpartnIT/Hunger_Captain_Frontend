{"ast":null,"code":"const token = '%[a-f0-9]{2}';\nconst singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nconst multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n  try {\n    // Try to decode the entire string first\n    return [decodeURIComponent(components.join(''))];\n  } catch {// Do nothing\n  }\n\n  if (components.length === 1) {\n    return components;\n  }\n\n  split = split || 1; // Split the array in 2 parts\n\n  const left = components.slice(0, split);\n  const right = components.slice(split);\n  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input);\n  } catch {\n    let tokens = input.match(singleMatcher) || [];\n\n    for (let i = 1; i < tokens.length; i++) {\n      input = decodeComponents(tokens, i).join('');\n      tokens = input.match(singleMatcher) || [];\n    }\n\n    return input;\n  }\n}\n\nfunction customDecodeURIComponent(input) {\n  // Keep track of all the replacements and prefill the map with the `BOM`\n  const replaceMap = {\n    '%FE%FF': '\\uFFFD\\uFFFD',\n    '%FF%FE': '\\uFFFD\\uFFFD'\n  };\n  let match = multiMatcher.exec(input);\n\n  while (match) {\n    try {\n      // Decode as big chunks as possible\n      replaceMap[match[0]] = decodeURIComponent(match[0]);\n    } catch {\n      const result = decode(match[0]);\n\n      if (result !== match[0]) {\n        replaceMap[match[0]] = result;\n      }\n    }\n\n    match = multiMatcher.exec(input);\n  } // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\n\n  replaceMap['%C2'] = '\\uFFFD';\n  const entries = Object.keys(replaceMap);\n\n  for (const key of entries) {\n    // Replace all decoded components\n    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n  }\n\n  return input;\n}\n\nexport default function decodeUriComponent(encodedURI) {\n  if (typeof encodedURI !== 'string') {\n    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n  }\n\n  try {\n    // Try the built in decoder first\n    return decodeURIComponent(encodedURI);\n  } catch {\n    // Fallback to a more advanced decoder\n    return customDecodeURIComponent(encodedURI);\n  }\n}","map":{"version":3,"names":["token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","split","decodeURIComponent","join","length","left","slice","right","Array","prototype","concat","call","decode","input","tokens","match","i","customDecodeURIComponent","replaceMap","exec","result","entries","Object","keys","key","replace","decodeUriComponent","encodedURI","TypeError"],"sources":["C:/Users/Davian/Desktop/techis-wd-forum-django-react/frontend/node_modules/query-string/node_modules/decode-uri-component/index.js"],"sourcesContent":["const token = '%[a-f0-9]{2}';\nconst singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nconst multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn [decodeURIComponent(components.join(''))];\n\t} catch {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tconst left = components.slice(0, split);\n\tconst right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch {\n\t\tlet tokens = input.match(singleMatcher) || [];\n\n\t\tfor (let i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher) || [];\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tconst replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD',\n\t};\n\n\tlet match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch {\n\t\t\tconst result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tconst entries = Object.keys(replaceMap);\n\n\tfor (const key of entries) {\n\t\t// Replace all decoded components\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nexport default function decodeUriComponent(encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}